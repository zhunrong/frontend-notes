(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{411:function(t,s,a){"use strict";a.r(s);var r=a(50),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" HTTP 缓存")]),t._v(" "),a("p",[t._v("通过合理利用 HTTP 缓存，可以极大的提升 Web 应用的访问速度，同时也能有效降低服务器的负载。")]),t._v(" "),a("p",[t._v("当客户端向服务端请求资源时，客户端可以首先检查本地缓存中是否存在资源的缓存，然后再决定是否向服务端发起请求。HTTP 缓存分为"),a("strong",[t._v("强缓存")]),t._v("和"),a("strong",[t._v("协商缓存")]),t._v("，在实际应用中是通过 HTTP 的头部字段来决定具体实施的缓存策略。")]),t._v(" "),a("h2",{attrs:{id:"强缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[t._v("#")]),t._v(" 强缓存")]),t._v(" "),a("p",[t._v("要采用"),a("strong",[t._v("强缓存")]),t._v("，服务端返回资源时要携带响应头 "),a("strong",[t._v("Cache-Control")]),t._v(" 并且值要满足：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("Cache-Control: max-age"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("seconds"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# <seconds> 表示缓存的有效时长（秒）")]),t._v("\n")])])]),a("p",[t._v("客户端再次请求同样的资源时，会判断当前时间距离缓存时间是否在有效期内，如果是则直接使用本地缓存，不向服务端发出真实的请求，但是对于客户端仍然像是一次完整的请求并且 HTTP 状态码为 200；如果判断超出缓存有效期，则降级到"),a("strong",[t._v("协商缓存")]),t._v("。")]),t._v(" "),a("p",[t._v("如果响应头没有 "),a("strong",[t._v("Cache-Control")]),t._v(" 字段，也可以使用 "),a("strong",[t._v("Expires")]),t._v(" 字段：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("Expires: Wed, "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("21")]),t._v(" Oct "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2015")]),t._v(" 07:28:00 GMT "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 表示资源的过期时间")]),t._v("\n")])])]),a("p",[t._v("客户端再次请求时，通过对比当前时间与这个时间来判断本地缓存是否有效。但是这个方案存在缺陷，因为 "),a("strong",[t._v("Expires")]),t._v(" 的时间是服务端时间，与客户端时间存在不同步的问题，因此现在主要采用 "),a("strong",[t._v("Cache-Control")]),t._v(" 方案。")]),t._v(" "),a("h2",{attrs:{id:"协商缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),a("p",[t._v("与强缓存不同，协商缓存时客户端无论如何都会向服务端发送一次请求。")]),t._v(" "),a("p",[t._v("要采用"),a("strong",[t._v("协商缓存")]),t._v("，服务端返回资源时要携带响应头 "),a("strong",[t._v("Cache-Control")]),t._v(" 并且值要满足：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("Cache-Control: no-cache "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启协商缓存")]),t._v("\n")])])]),a("p",[t._v("另外还有2组与"),a("strong",[t._v("协商缓存")]),t._v("相关的头部字段：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("Last-Modified")]),t._v(" / "),a("strong",[t._v("If-Modified-Since")])])]),t._v(" "),a("p",[t._v("语法：")]),t._v(" "),a("div",{staticClass:"language-shell extra-class"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("Last-Modified: "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("day-name"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(", "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("day"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("month"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("year"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("hour"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(":"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("minute"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(":"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("second"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" GMT "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 资源最近修改时间")]),t._v("\n")])])]),a("p",[t._v("服务端返回资源时，携带响应头 "),a("strong",[t._v("Last-Modified")]),t._v(" 字段表示资源的最近修改时间，客户端再次请求时，在请求头 "),a("strong",[t._v("If-Modified-Since")]),t._v(" 字段带上这个时间，服务端受理时会比较这个时间，如果资源没有更新则返回 304 HTTP 状态码（不返回 body），指示客户端可以使用本地缓存，否则返回 200 HTTP 状态码和最新的资源数据。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("ETag")]),t._v(" / "),a("strong",[t._v("If-None-Match")])])]),t._v(" "),a("p",[a("strong",[t._v("ETag")]),t._v(" HTTP 响应头是资源的特定版本的标识符，它的值根据资源的内容生成，只要内容变化，它的值就会变化。服务端返回资源时携带 "),a("strong",[t._v("ETag")]),t._v(" 响应头，客户端再次请求时，在请求头 "),a("strong",[t._v("If-None-Match")]),t._v(" 上附带这个值，服务端通过对比这个值，判断客户端缓存是否有效，从而响应 304 或 200 HTTP 状态码。")]),t._v(" "),a("p",[a("strong",[t._v("Last-Modified")]),t._v(" 时间只能精确到秒，因此如果在一秒内资源发生了变化，缓存协商时，会错误的认为资源没有变化。但是，这种缺陷通过 "),a("strong",[t._v("ETag")]),t._v(" 的方式得到了解决。当 "),a("strong",[t._v("ETag")]),t._v(" 和 "),a("strong",[t._v("Last-Modified")]),t._v(" 同时出现时，前者的优先级更高。")]),t._v(" "),a("h2",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 缓存"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);