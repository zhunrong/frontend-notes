# HTTP 缓存

通过合理利用 HTTP 缓存，可以极大的提升 Web 应用的访问速度，同时也能有效降低服务器的负载。

当客户端向服务端请求资源时，客户端可以首先检查本地缓存中是否存在资源的缓存，然后再决定是否向服务端发起请求。HTTP 缓存分为**强缓存**和**协商缓存**，在实际应用中是通过 HTTP 的头部字段来决定具体实施的缓存策略。

## 强缓存

要采用**强缓存**，服务端返回资源时要携带响应头 **Cache-Control** 并且值要满足：

```shell
Cache-Control: max-age=<seconds> # <seconds> 表示缓存的有效时长（秒）
```

客户端再次请求同样的资源时，会判断当前时间距离缓存时间是否在有效期内，如果是则直接使用本地缓存，不向服务端发出真实的请求，但是对于客户端仍然像是一次完整的请求并且 HTTP 状态码为 200；如果判断超出缓存有效期，则降级到**协商缓存**。

如果响应头没有 **Cache-Control** 字段，也可以使用 **Expires** 字段：

```shell
Expires: Wed, 21 Oct 2015 07:28:00 GMT # 表示资源的过期时间
```

客户端再次请求时，通过对比当前时间与这个时间来判断本地缓存是否有效。但是这个方案存在缺陷，因为 **Expires** 的时间是服务端时间，与客户端时间存在不同步的问题，因此现在主要采用 **Cache-Control** 方案。

## 协商缓存

与强缓存不同，协商缓存时客户端无论如何都会向服务端发送一次请求。

要采用**协商缓存**，服务端返回资源时要携带响应头 **Cache-Control** 并且值要满足：

```shell
Cache-Control: no-cache # 开启协商缓存
```

另外还有2组与**协商缓存**相关的头部字段：

1. **Last-Modified** / **If-Modified-Since**

语法：

```shell
Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT # 资源最近修改时间
```

服务端返回资源时，携带响应头 **Last-Modified** 字段表示资源的最近修改时间，客户端再次请求时，在请求头 **If-Modified-Since** 字段带上这个时间，服务端受理时会比较这个时间，如果资源没有更新则返回 304 HTTP 状态码（不返回 body），指示客户端可以使用本地缓存，否则返回 200 HTTP 状态码和最新的资源数据。

2. **ETag** / **If-None-Match**

**ETag** HTTP 响应头是资源的特定版本的标识符，它的值根据资源的内容生成，只要内容变化，它的值就会变化。服务端返回资源时携带 **ETag** 响应头，客户端再次请求时，在请求头 **If-None-Match** 上附带这个值，服务端通过对比这个值，判断客户端缓存是否有效，从而响应 304 或 200 HTTP 状态码。

**Last-Modified** 时间只能精确到秒，因此如果在一秒内资源发生了变化，缓存协商时，会错误的认为资源没有变化。但是，这种缺陷通过 **ETag** 的方式得到了解决。当 **ETag** 和 **Last-Modified** 同时出现时，前者的优先级更高。

## 参考

1. [HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)